<!DOCTYPE html>
<html>
  <head>
    <style>
      .stage {
        background-color: #f0f0f0;
      }
    </style>
    <script src="lib.js"></script>
  </head>
  <body>
    <div id="mount"></div>

    <script data-id="2d-vertex" type="x-shader/x-vertex">
    
      attribute vec2 a_position;
      attribute vec2 a_texCoord;
      uniform vec2 u_resolution;
      varying vec2 v_texCoord;

      void main() {
         // convert the rectangle from pixels to 0.0 to 1.0
         vec2 zeroToOne = a_position / u_resolution;

         // convert from 0->1 to 0->2
         vec2 zeroToTwo = zeroToOne * 2.0;

         // convert from 0->2 to -1->+1 (clipspace)
         vec2 clipSpace = zeroToTwo - 1.0;

         gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

         // pass the texCoord to the fragment shader
         // The GPU will interpolate this value between points.
         v_texCoord = a_texCoord;
      }

    </script>
     
    <script data-id="2d-fragment" type="x-shader/x-fragment">

      precision mediump float;

      // our texture
      uniform sampler2D u_image;

      // the texCoords passed in from the vertex shader.
      varying vec2 v_texCoord;

      void main() {
         gl_FragColor = texture2D(u_image, v_texCoord);
      }

    </script>

    <script>

      'use strict';

      var CANVAS_WIDTH = 400;
      var CANVAS_HEIGHT = 300;
      var VIEWPORT_WIDTH = 400;
      var VIEWPORT_HEIGHT = 300;

      function createShaders(gl, vertexId, fragmentId) {

        var vertexShaderSource = getVertexShaderFromTemplate(vertexId);
        var fragmentShaderSource = getFragmentShaderFromTemplate(fragmentId);

        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);

        return {
          vertex: vertexShader,
          fragment: fragmentShader
        };
      }

      function createProgram(gl, shaders) {

        var program = gl.createProgram();
        gl.attachShader(program, shaders.vertex);
        gl.attachShader(program, shaders.fragment);

        gl.linkProgram(program);
        gl.useProgram(program);

        return program;
      }

      function setViewport(gl, x, y, width, height) {
        gl.viewport(x, y, width, height);
      }

      function setRectangle(gl, x, y, width, height) {
        var x1 = x;
        var x2 = x + width;
        var y1 = y;
        var y2 = y + height;
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
          x1, y1,
          x2, y1,
          x1, y2,
          x1, y2,
          x2, y1,
          x2, y2]), gl.STATIC_DRAW);
      }

      function go(canvas, gl, image) {

        // look up where the vertex data needs to go.
        var positionLocation = gl.getAttribLocation(program, 'a_position');
        var texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');

        // provide texture coordinates for the rectangle.
        var texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
          0.0,  0.0,
          1.0,  0.0,
          0.0,  1.0,
          0.0,  1.0,
          1.0,  0.0,
          1.0,  1.0]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(texCoordLocation);
        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

        // Create a texture.
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);

        // Set the parameters so we can render any size image.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        // Upload the image into the texture.
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

        // lookup uniforms
        var resolutionLocation = gl.getUniformLocation(program, 'u_resolution');

        // set the resolution
        gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

        // Create a buffer for the position of the rectangle corners.
        var buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // Set a rectangle the same size as the image.
        setRectangle(gl, 0, 0, image.width, image.height);

        // Draw the rectangle.
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }

      var canvas = createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT, 'stage', '#mount');
      var gl = canvas.getContext('webgl');

      if (gl) {
        var shaders = createShaders(gl, '2d-vertex', '2d-fragment');
        var program = createProgram(gl, shaders);
        setViewport(gl, 0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);

        loadImage('image.png', function (image) {
          go(canvas, gl, image);
        });

      } else {
        alert('Sorry, your browser does not support WebGL');
      }

    </script>
  </body>
</html>