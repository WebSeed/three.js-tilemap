<!DOCTYPE html>
<html>
  <head>
    <style>
      .stage {
        background-color: red;
      }
    </style>
    <script src="lib.js"></script>
  </head>
  <body>
    <div id="mount"></div>

    <script data-id="2d-vertex" type="x-shader/x-vertex">

      attribute vec2 a_position;
      uniform vec2 u_resolution;
       
      void main() {
        // Convert the rectangle from pixels to 0.0 to 1.0
        vec2 zeroToOne = a_position / u_resolution;

        // Convert from 0->1 to 0->2
        vec2 zeroToTwo = zeroToOne * 2.0;

        // Convert from 0->2 to -1->+1 (clipspace)
        vec2 clipSpace = zeroToTwo - 1.0;

        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        // gl_Position = vec4(clipSpace, 0, 1);
      }
    </script>
     
    <script data-id="2d-fragment" type="x-shader/x-fragment">

      precision mediump float;

      uniform vec4 u_color;

      void main() {
        gl_FragColor = u_color; // vec4(0, 0, 1, 1);
      }
    </script>

    <!--
    <script data-id="vertex" type="x-shader/x-vertex">
      attribute vec2 aVertex;
      attribute vec2 aUV; 
      varying vec2 vTex;
      uniform vec2 pos;
      void main(void) {
        gl_Position = vec4(aVertex + pos, 0.0, 1.0);
        vTex = aUV;
      }
    </script>

    <script data-id="fragment" type="x-shader/x-fragment">
      precision highp float;
      varying vec2 vTex;
      uniform sampler2D sampler0;
      void main(void) {
        gl_FragColor = texture2D(sampler0, vTex);
      }
    </script>
    -->

    <script>

      'use strict';

      var CANVAS_WIDTH = 400;
      var CANVAS_HEIGHT = 300;
      var VIEWPORT_WIDTH = 400;
      var VIEWPORT_HEIGHT = 300;

      function createShaders(gl, vertexId, fragmentId) {

        var vertexShaderSource = getVertexShaderFromTemplate(vertexId);
        var fragmentShaderSource = getFragmentShaderFromTemplate(fragmentId);

        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);

        return {
          vertex: vertexShader,
          fragment: fragmentShader
        };
      }

      function createProgram(gl, shaders) {

        var program = gl.createProgram();
        gl.attachShader(program, shaders.vertex);
        gl.attachShader(program, shaders.fragment);

        gl.linkProgram(program);
        gl.useProgram(program);

        return program;
      }

      function setViewport(gl, x, y, width, height) {
        gl.viewport(x, y, width, height);
      }

      function go(canvas, gl) {

        var shaders = createShaders(gl, '2d-vertex', '2d-fragment');
        var program = createProgram(gl, shaders);

        setViewport(gl, 0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);
 
        // Look up where the vertex data needs to go
        var positionLocation = gl.getAttribLocation(program, 'a_position');
         
        // Set the resolution
        var resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

        // Set the color
        var colorLocation = gl.getUniformLocation(program, 'u_color');
        gl.uniform4f(colorLocation, Math.random(), Math.random(), Math.random(), 1);

        // Create a buffer and put a single clipspace rectangle in it (2 triangles)
        var buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(
              [
                20, 20,
                200, 20,
                20, 200,
                20, 200,
                200, 20,
                200, 200
              ]
            ),
            gl.STATIC_DRAW
        );
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
         
        // Draw
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        window.gl = gl;

        // var vertexBuffer = gl.createBuffer();
        // gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        // gl.bufferData(
        //   gl.ARRAY_BUFFER,
        //   new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]),
        //   gl.STATIC_DRAW
        // );

        // var textureBuffer = gl.createBuffer();
        // gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
        // gl.bufferData(
        //   gl.ARRAY_BUFFER,
        //   new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]),
        //   gl.STATIC_DRAW
        // );

        // var vloc = gl.getAttribLocation(program, 'aVertex'); 
        // var tloc = gl.getAttribLocation(program, 'aUV');
        // var uLoc = gl.getUniformLocation(program, 'pos');

        // loadImage('image.png', function (image) {

        //   var texture = gl.createTexture();
        //   gl.bindTexture(gl.TEXTURE_2D, texture);
        //   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        //   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        //   gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

        //   gl.enableVertexAttribArray(vloc);
        //   gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        //   gl.vertexAttribPointer(vloc, 2, gl.FLOAT, false, 0, 0);

        //   gl.enableVertexAttribArray(tloc);
        //   gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
        //   gl.bindTexture(gl.TEXTURE_2D, texture);
        //   gl.vertexAttribPointer(tloc, 2, gl.FLOAT, false, 0, 0);

        //   // Draw!
        //   gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        // });
      }

      var canvas = createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT, 'stage', '#mount');
      var gl = canvas.getContext('webgl');
      gl ? go(canvas, gl) : alert('Sorry, your browser does not support WebGL');

    </script>
  </body>
</html>